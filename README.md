Goal: To make a Python program that will output the moves to reach the solution to any input scrambled Rubik's Clock.

Preface:
A Rubik's Clock has two sides: a Light Blue side (referred to as L) and a Dark Blue side (referred to as B). There are nine clocks on each side, with twelve positions each. In the four corners, there are gears which can be spun in order to perform a move, which will spin some of the hands of the clocks. In the center of the puzzle, there are 4 pins, which can each be pressed down or up in order to modify which clock hands will spin. The goal of the puzzle is to get all clock hands to point to 12.]

Process:
Going into this project, I decided to use as little outside help as possible (I later gave up on this endeavor), so I created my own notation to dictate every possible move that can be performed on the puzzle. I decided to set the standard orientation to have side L face up and the 12 side of the clocks on the top. I will spare you the details of every single move (as this quickly grew overcomplicated), but I found that some moves result in all four gears performing the same rotation, while others divide the gears into two groups; where one set of gears makes one rotation, and the rest of the gears make another rotation. To notate this, I wrote what looks like a tic-tac-toe board, but it just shows which gears rotate which clocks. I used an O to notate one set of the gears and an X to notate the others. This is why the original notation has moves like BO and BX, because BO simply means "Move-B with gear set O." The apostrophe means rotate the gears counter clockwise. After I mapped every move, I realized that there happened to be exactly 26 possible moves with no redundancies, so I assigned each move a different letter of the alphabet to represent it.

I then began programming. I created the draw_board() function to represent the puzzle. I stored the puzzle in a 2 dimensional (3x3) array of numbers representing the number the hand of each clock is pointing at. (Note: Side B is "x-ray"ed, so it is the current state of side B, as if you were looking straight through side L. I did it this way because it was easier to keep track of in my head, no other reason)

After this, I made the make_move() function, which interprets my original move notation or the alphabet notation and performs the move on the input state of the puzzle, returning the new state of the puzzle. Then I made the is_puzzle_solved function, which does exactly as it's name suggests.

Next, I began work on figuring out how to solve it. My first inclination was to try and brute force it, so I made a few brute force functions, but after letting that run for a few hours, the Python terminal crashed because it was using too much memory to store the moves. Then I tried writing the moves to a file instead, but after letting it run over-night and seeing that the program had not ended, I calculated how long it would take to brute force a solution if it would take ~10 moves. This came out to around 52 years, so I switched my attention to learning the algorithms people have already come up with to solve it.

After learning how to solve the puzzle, I programmed a solver() function, which uses 12 steps to solve it (based on this solution: https://safalra.com/other/rubiks-clock-solution/) and returns a list of moves it took to do so. Finally, after testing the solver and affirming that it works, I created the solution_interpreter() function, which takes the move list output of the solver and outputs an interpretation of it for those who don't want to learn my notation.
